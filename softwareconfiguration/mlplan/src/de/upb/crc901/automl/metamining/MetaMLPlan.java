package de.upb.crc901.automl.metamining;

import java.io.File;
import java.io.IOException;
import java.util.Collection;
import java.util.List;
import java.util.Random;
import java.util.Timer;
import java.util.TimerTask;

import org.apache.commons.lang3.time.StopWatch;

import de.upb.crc901.automl.hascowekaml.WEKAPipelineFactory;
import de.upb.crc901.automl.metamining.pipelinecharacterizing.WEKAPipelineCharacterizer;
import de.upb.crc901.automl.pipeline.basic.MLPipeline;
import hasco.core.HASCOProblemReduction;
import hasco.core.Util;
import hasco.model.Component;
import hasco.model.ComponentInstance;
import jaicore.graphvisualizer.SimpleGraphVisualizationWindow;
import jaicore.ml.evaluation.MonteCarloCrossValidationEvaluator;
import jaicore.ml.evaluation.MulticlassEvaluator;
import jaicore.ml.metafeatures.GlobalCharacterizer;
import jaicore.planning.algorithms.forwarddecomposition.ForwardDecompositionHTNPlannerFactory;
import jaicore.planning.graphgenerators.task.tfd.TFDNode;
import jaicore.planning.graphgenerators.task.tfd.TFDTooltipGenerator;
import jaicore.search.algorithms.standard.core.ORGraphSearch;
import jaicore.search.algorithms.standard.lds.BestFirstLimitedDiscrepancySearch;
import jaicore.search.algorithms.standard.lds.NodeOrderList;
import jaicore.search.structure.core.GraphGenerator;
import weka.classifiers.AbstractClassifier;
import weka.classifiers.Classifier;
import weka.core.Instance;
import weka.core.Instances;

public class MetaMLPlan extends AbstractClassifier {

	/**
	 * Generated by Eclipse
	 */
	private static final long serialVersionUID = 4772178784402396834L;

	private ORGraphSearch<TFDNode, String, NodeOrderList> lds;
	private long timeoutInMilliseconds = 60000;
	private Classifier bestModel;
	private Collection<Component> components;
	private WEKAMetaminer metaMiner;

	public MetaMLPlan() throws IOException {
		this(new File("model/weka/weka-all-autoweka.json"));
	}

	public MetaMLPlan(File configFile) throws IOException {
		// Get the graph generator from the reduction
		HASCOProblemReduction reduction = new HASCOProblemReduction(configFile, "AbstractClassifier", true);
		components = reduction.getComponents();
		GraphGenerator<TFDNode, String> graphGenerator = reduction
				.getGraphGeneratorUsedByHASCOForSpecificPlanner(new ForwardDecompositionHTNPlannerFactory<Double>());
		WEKAPipelineCharacterizer chara = new WEKAPipelineCharacterizer(reduction.getParamRefinementConfig());
		metaMiner = new WEKAMetaminer(reduction.getParamRefinementConfig());
		lds = new BestFirstLimitedDiscrepancySearch<>(graphGenerator,
				(n1, n2) -> chara.test(n1, n1, reduction.getComponents()));
	}
	
	public void buildMetaComponents() throws Exception {
		metaMiner.build(null, null, null);
	}

	@Override
	public void buildClassifier(Instances data) throws Exception {
		// start timer
		TimerTask tt = new TimerTask() {

			@Override
			public void run() {
				lds.cancel();
			}
		};
		new Timer().schedule(tt, timeoutInMilliseconds);
		
		// characterize data set and give to meta miner
		metaMiner.setDataSetCharacterization(new GlobalCharacterizer().characterize(data));

		// search for solutions
		bestModel = null;
		double bestScore = 1;
		while (!lds.isInterrupted()) {
			List<TFDNode> solution = lds.nextSolution();
			if (solution == null)
				break;
			try {
				ComponentInstance ci = Util.getSolutionCompositionFromState(components,
						solution.get(solution.size() - 1).getState());
				WEKAPipelineFactory factory = new WEKAPipelineFactory();
				MLPipeline pl = factory.getComponentInstantiation(ci);
				StopWatch watch = new StopWatch();
				watch.start();
				MonteCarloCrossValidationEvaluator mccv = new MonteCarloCrossValidationEvaluator(
						new MulticlassEvaluator(new Random(0)), 3, data, .7f);
				watch.stop();
				long expectedTimeForTraining = watch.getTime() / 2;
				double score = mccv.evaluate(pl);
				System.out.println(score + " " + pl);
				if (score < bestScore) {
					bestModel = pl;
					bestScore = score;
				}
			} catch (Throwable e) {
				e.printStackTrace();
			}

			// This needs approx. expectedTimeForTraining much time
			// TODO time this also somehow (stop search so enough time for training this)
			bestModel.buildClassifier(data);
		}

		System.out.println("Meta MLPlan ready. Best solution: " + bestModel);
	}

	@Override
	public double classifyInstance(final Instance instance) throws Exception {
		return bestModel.classifyInstance(instance);
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	public void enableVisualization(boolean withToolTips) {
		SimpleGraphVisualizationWindow window = new SimpleGraphVisualizationWindow<>(lds);
		if (withToolTips) {
			window.getPanel().setTooltipGenerator(new TFDTooltipGenerator<>());
		}
	}

	public void setTimeOutInSeconds(int seconds) {
		this.timeoutInMilliseconds = seconds * 1000;
	}
}
