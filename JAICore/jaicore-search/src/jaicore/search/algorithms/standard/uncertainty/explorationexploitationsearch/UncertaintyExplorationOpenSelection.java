package jaicore.search.algorithms.standard.uncertainty.explorationexploitationsearch;

import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Queue;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jaicore.search.algorithms.standard.uncertainty.ISolutionDistanceMetric;
import jaicore.search.model.travesaltree.Node;

public class UncertaintyExplorationOpenSelection<T, V extends Comparable<V>> implements Queue<Node<T, V>> {

	private static final Logger logger = LoggerFactory.getLogger(UncertaintyExplorationOpenSelection.class);

	private final Queue<Node<T, V>> exploitationOpen = new PriorityQueue<>();
	private final PriorityQueue<Node<T, V>> explorationOpen = new PriorityQueue<>();
	private final ISolutionDistanceMetric<T> solutionDistanceMetric;
	private final IPhaseLengthAdjuster phaseLengthAdjuster;
	private final IExplorationCandidateSelector<T, V> candidateSelector;
	private int explorationPhaseLength;
	private int exploitationPhaseLength;
	double exploitationScoreThreshold;
	double explorationUncertaintyThreshold;
	private int selectedNodes = 0;
	private int exploredNodes = 0;
	private long timeout;
	private long startTime;
	private boolean exploring = true;

	public UncertaintyExplorationOpenSelection(long timeout, int phaseInterval, double exploitationScoreThreshold,
			double explorationUncertaintyThreshold, IPhaseLengthAdjuster phaseLengthAdjuster,
			ISolutionDistanceMetric<T> solutionDistanceMetric, IExplorationCandidateSelector<T, V> candidateSelector) {
		super();
		this.timeout = timeout;
		this.startTime = System.currentTimeMillis();
		int[] phaseLenghts = phaseLengthAdjuster.getInitialPhaseLengths(phaseInterval);
		assert phaseLenghts.length == 2;
		this.explorationPhaseLength = phaseLenghts[0];
		this.exploitationPhaseLength = phaseLenghts[1];
		this.exploitationScoreThreshold = exploitationScoreThreshold;
		this.explorationUncertaintyThreshold = explorationUncertaintyThreshold;
		this.phaseLengthAdjuster = phaseLengthAdjuster;
		this.solutionDistanceMetric = solutionDistanceMetric;
		this.candidateSelector = candidateSelector;
	}

	@Override
	public Node<T, V> peek() {
		return selectCandidate(exploring);
	}

	private Node<T, V> selectCandidate(boolean isExploring) {
		Comparator<Node<T, V>> comparator = (n1, n2) -> {
			try {
				Double u1 = (Double) n1.getAnnotation("uncertainty");
				Double u2 = (Double) n2.getAnnotation("uncertainty");
				V v1 = n1.getInternalLabel();
				V v2 = n2.getInternalLabel();
				if (isExploring) {
					if (Math.abs(u1 - u2) <= this.explorationUncertaintyThreshold) {
						return -1 * v1.compareTo(v2);
					} else {
						return Double.compare(u1, u2);
					}
				} else {
					if (v1 instanceof Double && v2 instanceof Double) {
						Double s1 = (Double) v1;
						Double s2 = (Double) v2;
						if (Math.abs(s1 - s2) <= this.exploitationScoreThreshold) {
							return Double.compare(u1, u2);
						} else {
							return Double.compare(s1, s2);
						}
					} else {
						if (v1 instanceof Double && v2 instanceof Double) {
							Double s1 = (Double) v1;
							Double s2 = (Double) v2;
							if (Math.abs(s1 - s2) <= this.exploitationScoreThreshold) {
								return Double.compare(u1, u2);
							} else {
								return v1.compareTo(v2);
							}
						} else {
							return v1.compareTo(v2);
						}
					}
				}
			} catch (Exception e) {
				logger.error(e.getMessage());
				return 0;
			}
		};
		if (isExploring) {
			return explorationOpen.stream().max(comparator).orElse(explorationOpen.peek());
		} else {
			return exploitationOpen.stream().min(comparator).orElse(exploitationOpen.peek());
		}
	}

	private void adjustPhaseLengths(long passedTime) {
		int[] newPhaseLengths = this.phaseLengthAdjuster.adjustPhaseLength(explorationPhaseLength,
				exploitationPhaseLength, passedTime, this.timeout);
		assert newPhaseLengths.length == 2;
		this.explorationPhaseLength = newPhaseLengths[0];
		this.exploitationPhaseLength = newPhaseLengths[1];
	}

	@Override
	public boolean add(Node<T, V> node) {
		assert node != null : "Cannot add node NULL to OPEN";
		assert !contains(node) : "Node " + node + " is already there!";
		if (exploring) {
			return explorationOpen.add(node);
		} else
			return exploitationOpen.add(node);
	}

	@Override
	public boolean remove(Object node) {
		assert !(exploitationOpen.contains(node) && explorationOpen.contains(node)) : "A node (" + node
				+ ") that is to be removed is in BOTH open lists!";
		if (exploring) {
			return explorationOpen.remove(node) || exploitationOpen.remove(node);
		} else {
			return exploitationOpen.remove(node) || explorationOpen.remove(node);
		}
	}

	@Override
	public boolean addAll(Collection<? extends Node<T, V>> arg0) {
		assert exploitationOpen != null : "Primary OPEN is NULL!";
		if (arg0 == null)
			throw new IllegalArgumentException("Cannot add NULL collection");
		if (arg0.contains(null))
			throw new IllegalArgumentException("Cannot add collection that contains NULL");
		if (exploring) {
			return explorationOpen.addAll(arg0);
		} else
			return exploitationOpen.addAll(arg0);
	}

	@Override
	public void clear() {
		exploitationOpen.clear();
		explorationOpen.clear();
	}

	@Override
	public boolean contains(Object arg0) {
		return exploitationOpen.contains(arg0) || explorationOpen.contains(arg0);
	}

	@Override
	public boolean containsAll(Collection<?> arg0) {
		for (Object o : arg0) {
			if (!contains(o))
				return false;
		}
		return true;
	}

	@Override
	public boolean isEmpty() {
		return exploitationOpen.isEmpty() && explorationOpen.isEmpty();
	}

	@Override
	public Iterator<Node<T, V>> iterator() {
		return exploring ? explorationOpen.iterator() : exploitationOpen.iterator();
	}

	@Override
	public boolean removeAll(Collection<?> arg0) {
		return exploitationOpen.removeAll(arg0) && explorationOpen.removeAll(arg0);
	}

	@Override
	public boolean retainAll(Collection<?> arg0) {
		return exploitationOpen.retainAll(arg0) && explorationOpen.retainAll(arg0);
	}

	@Override
	public int size() {
		return exploitationOpen.size() + explorationOpen.size();
	}

	@Override
	public Object[] toArray() {
		return exploitationOpen.toArray();
	}

	@SuppressWarnings("unchecked")
	@Override
	public <X> X[] toArray(X[] arg0) {
		return (X[]) exploitationOpen.toArray();
	}

	@Override
	public Node<T, V> element() {
		return peek();
	}

	@Override
	public boolean offer(Node<T, V> e) {
		return add(e);
	}

	@Override
	public Node<T, V> poll() {
		return remove();
	}

	@Override
	public Node<T, V> remove() {

		/* determine element to be returned and remove it from the respective list */
		Node<T, V> peek = peek();
		remove(peek);

		/* update internal state */
		if (!exploring) {
			selectedNodes++;
			if (selectedNodes % exploitationPhaseLength == 0) {
				List<Node<T, V>> explorationCandidates = candidateSelector.selectExplorationCandidates(exploitationOpen,
						exploitationOpen.peek(), solutionDistanceMetric);

				/* enable exploration with the node selected by the explorer evaluator */
				try {
					logger.info("Entering exploration phase under {}", explorationCandidates);
				} catch (Exception e) {
					logger.error(e.getMessage());
				}
				exploring = true;
				exploredNodes = 0;
				exploitationOpen.removeAll(explorationCandidates);
				explorationOpen.clear();
				explorationOpen.addAll(explorationCandidates);
			}
		} else {
			exploredNodes++;
			if (exploredNodes > explorationPhaseLength || explorationOpen.isEmpty()) {
				adjustPhaseLengths(System.currentTimeMillis() - this.startTime);
				exploring = false;
				exploitationOpen.addAll(explorationOpen);
				explorationOpen.clear();
				logger.info("Entering exploitation phase");
			}
		}

		/* return the peeked element */
		return peek;
	}
}
